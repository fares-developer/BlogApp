
EXPLICACIÓN

-Arquitectura
Utilizaremos generalmente la conocida como MVVM:

                        #################################
                               ACTIVITY/FRAGMENT        --> Lo que el usuario ve
                        #################################
                             VIEWMODEL (LIVE DATA)      --> Lo que se necesita para ver los fragments/activities
                        #################################
                                @REPOSITORY@ (Se encarga de buscar la info que necesitamos para la app por diferentes vías
                                     / \
SQLITE <------ MODEL(ROOM) <--------/   \-------> REMOTE DATA SOURCE (RETROFIT)--> WEBSERVICE


Más información en https://developer.android.com/jetpack/guide?hl=es-419

-ACTIVITY/FRAGMENT(UI)
En esta capa se muestra to-do lo que el usuario ve e interactúa

-ViewModel y LiveData(Presentation)
En esta capa se gestionan las vistas del apartado anterior almacenando información de aquellas vistas
ya renderizadas y su información así no tienen que regenerarse to-do el rato

-REPOSITORY
En esta capa nos encargamos de implementar una interfaz y una clase que trabajaran en conjunto, donde
definiremos cómo se van a buscar los recursos que necesitamos para la aplicacion.

-DATA
En esta capa encontramos los datos con los que trabajaremos ya sea en local (SQlite) o en remoto(Retrofit y otros),
esta capa requiere del modelo del viewModel



-CORRUTINAS
Las utilizaremos para no tener que hacer llamadas constantes sin saber cuándo el servidor
nos responde y trae los datos. Las corrutinas es una función que se puede suspender
hasta que no haya realizado su tarea, por ejemplo si hacemos una petición al servidor y este tarda
en responder, la función se pone en suspensión hasta que responda el servidor, momento en el que
se reanuda y concluye.

Más información en https://developer.android.com/kotlin/coroutines?hl=es&gclid=CjwKCAjwgr6TBhAGEiwA3aVuIXnlDkrAGC2jSgxAF4bz8fAclO4O1rd-U-JVgn55bjwurhP-gY6eRhoCDb0QAvD_BwE&gclsrc=aw.ds



CONCATADAPTER
Es una librería de recyclerview que nos permite escribir un adaptador para cada sección
del código, en este caso crearemos adaptadores para upcoming-movies top-rated y popular

Utilizaremos una librería llamada glide para mostrar las imágenes que nos vienen de internet
'com.github.bumptech.glide:glide:4.11.0', annotatonProcessor 'com.github.bumptech.glide:compiler:4.11.0'


ROOM
Lo utilizamos para acceder localmente a nuestros datos. En este proyecto haremos una petición al servidor,
insertamos esos datos en una base de datos y a partir de ahí empezamos a solicitar los datos que mostramos
en la app desde ROOM y no directamente desde internet, si se pierde la conexión se mostrarán los datos
de la última petición.

Para trabajar con Room necesitamos lo siguiente:

-La entidad/entidades: Las tablas y sus columnas las cuales serán data class con @Entity en la
declaración de la clase, @PrimaryKey en la clave primaria y @ColumnInfo en las columnas o registros

-El DAO(Data Access Object): Es el encargado de las modificaciones en la tabla,DML y SELECT. Cuando
insertamos los datos pueden duplicarse para evitarlo utilizamos el onConflict para remplazar los datos

-El Room Database: Debemos declarar esta AppDatabase abstracta para poder acceder
a los métodos abstractos, entre los cuales tendremos nuestro DAO. El Room Database va con un
@Database en la declaración de la clase, a dicha declaración le pasamos un array de entidades y la
versión de la base de datos.